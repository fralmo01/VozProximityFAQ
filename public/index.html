<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOX PROXIMITY HUD</title>
    <!-- Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Roboto+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <!-- Icon -->
    <link rel="icon" href="https://img.icons8.com/color/48/minecraft-main-character.png" type="image/x-icon">

    <style>
        :root {
            --bg-color: #0a0a0a;
            --glass-bg: rgba(20, 20, 20, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
            --primary-accent: #00ff88;
            /* Neon Green */
            --danger-accent: #ff004c;
            /* Neon Red */
            --text-color: #e0e0e0;
            --muted-text: #888;
            --font-display: 'Rajdhani', sans-serif;
            --font-mono: 'Roboto Mono', monospace;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-display);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 255, 136, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255, 0, 76, 0.05) 0%, transparent 20%);
        }

        /* --- UTILS --- */
        .hidden {
            display: none !important;
        }

        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .items-center {
            align-items: center;
        }

        .justify-center {
            justify-content: center;
        }

        /* --- GLASS CONTAINER --- */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            padding: 2rem;
            width: 100%;
            max-width: 500px;
            transition: all 0.3s ease;
        }

        /* --- LOGIN VIEW --- */
        #login-view {
            text-align: center;
        }

        .logo {
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 4px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            margin-bottom: 2rem;
            color: white;
        }

        .input-group {
            margin-bottom: 2rem;
            width: 100%;
        }

        input[type="text"] {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            color: var(--primary-accent);
            font-family: var(--font-mono);
            font-size: 1.2rem;
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
            outline: none;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            border-color: var(--primary-accent);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.1);
        }

        .visualizer-container {
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--glass-border);
        }

        .audio-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--primary-accent), #00cc6a);
            transition: width 0.05s linear;
            box-shadow: 0 0 15px var(--primary-accent);
        }

        .btn-start {
            background: var(--primary-accent);
            color: #000;
            border: none;
            padding: 1rem 2rem;
            font-family: var(--font-display);
            font-weight: 700;
            font-size: 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
        }

        .btn-start:hover {
            transform: scale(1.02);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }

        .btn-start:disabled {
            background: #333;
            color: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* --- HUD VIEW --- */
        #hud-view {
            width: 90vw;
            max-width: 1200px;
            height: 85vh;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 1.5rem;
        }

        /* HUD Header */
        .hud-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
        }

        .user-status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .avatar-glow {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #333;
            box-shadow: 0 0 10px #333;
            transition: all 0.1s;
        }

        .avatar-glow.active {
            background: var(--primary-accent);
            box-shadow: 0 0 20px var(--primary-accent);
        }

        .current-user {
            font-family: var(--font-mono);
            font-size: 1.1rem;
            color: var(--primary-accent);
        }

        /* HUD Main - Radar List */
        .radar-container {
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        /* Scrollbar */
        .radar-container::-webkit-scrollbar {
            width: 6px;
        }

        .radar-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .radar-container::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .radar-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.03);
            border-left: 3px solid #555;
            padding: 1rem;
            margin-bottom: 0.8rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 4px;
            transition: all 0.3s ease;
            animation: fadeIn 0.4s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .player-card.in-range {
            border-left-color: var(--primary-accent);
            background: rgba(0, 255, 136, 0.05);
        }

        .player-card.out-range {
            border-left-color: var(--danger-accent);
            opacity: 0.6;
        }

        .player-info {
            display: flex;
            flex-direction: column;
        }

        .player-name {
            font-weight: 700;
            font-size: 1.1rem;
            letter-spacing: 1px;
        }

        .player-details {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--muted-text);
            margin-top: 4px;
            display: flex;
            gap: 10px;
        }

        .status-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .bg-cave {
            background: #4a3b75;
            color: #cabaff;
        }

        .bg-scream {
            background: #5e1124;
            color: #ff8ca3;
            animation: pulseRed 1s infinite;
        }

        @keyframes pulseRed {
            0% {
                box-shadow: 0 0 0 0 rgba(220, 20, 60, 0.4);
            }

            70% {
                box-shadow: 0 0 0 6px rgba(220, 20, 60, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(220, 20, 60, 0);
            }
        }

        .distance-indicator {
            font-family: var(--font-mono);
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* HUD Footer - Controls */
        .hud-controls {
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            border-radius: 8px;
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
        }

        label {
            font-weight: 600;
            white-space: nowrap;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--primary-accent);
            height: 4px;
            background: #333;
            border-radius: 2px;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-accent);
            cursor: pointer;
            box-shadow: 0 0 10px var(--primary-accent);
        }

        .btn-mute {
            background: transparent;
            border: 1px solid var(--danger-accent);
            color: var(--danger-accent);
            padding: 0.5rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-weight: bold;
            transition: all 0.2s;
        }

        .btn-mute.muted {
            background: var(--danger-accent);
            color: black;
            box-shadow: 0 0 15px rgba(255, 0, 76, 0.4);
        }
    </style>

    <!-- Dependencies -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>

<body>

    <!-- VISTA 1: LOGIN -->
    <div id="login-view" class="glass-panel">
        <div class="logo">VOX PROXIMITY</div>

        <div class="input-group">
            <input type="text" id="username" placeholder="Ingresa tu Minecraft ID..." autocomplete="off">
        </div>

        <div class="visualizer-container">
            <div id="mic-bar" class="audio-bar"></div>
        </div>

        <button id="btn-join" class="btn-start" disabled>INICIAR SISTEMA</button>
        <p id="status-msg" style="margin-top: 10px; color: #666; font-size: 0.9rem;">Esperando acceso al micr√≥fono...
        </p>
    </div>

    <!-- VISTA 2: HUD -->
    <div id="hud-view" class="glass-panel hidden">
        <!-- Header -->
        <div class="hud-header">
            <div class="user-status">
                <div id="self-glow" class="avatar-glow"></div>
                <div class="current-user">Conectado como: <span id="display-username" style="color: white;">---</span>
                </div>
            </div>
            <div class="system-status" style="color: var(--primary-accent); font-size: 0.9rem;">
                ONLINE ‚óè
            </div>
        </div>

        <!-- Radar List -->
        <div id="radar-list" class="radar-container">
            <!-- JS Inject Players Here -->
        </div>

        <!-- Controls -->
        <div class="hud-controls">
            <button id="btn-toggle-mute" class="btn-mute">MIC ON</button>
            <div class="control-group">
                <label>Volumen General</label>
                <input type="range" id="master-volume" min="0" max="2" step="0.1" value="1">
            </div>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const MAX_DISTANCE = 60; // Metros
        const SCREAM_THRESHOLD = -5; // dB
        const NORMAL_ROLLOFF = 20; // Atenuaci√≥n normal hasta 20m

        // --- STATE ---
        let myUsername = null;
        let localStream = null;
        let audioContext = null;
        let socket = null;
        let peer = null;
        let peers = {}; // { username: { call, conn, ... } }
        let playersState = []; // Data from socket
        let isMuted = false;
        let masterGainNode = null;

        // --- DOM ELEMENTS ---
        const loginView = document.getElementById('login-view');
        const hudView = document.getElementById('hud-view');
        const usernameInput = document.getElementById('username');
        const btnJoin = document.getElementById('btn-join');
        const micBar = document.getElementById('mic-bar');
        const statusMsg = document.getElementById('status-msg');
        const radarList = document.getElementById('radar-list');
        const selfGlow = document.getElementById('self-glow');
        const displayUsername = document.getElementById('display-username');
        const btnToggleMute = document.getElementById('btn-toggle-mute');
        const masterVolumeSlider = document.getElementById('master-volume');

        // --- 1. INITIAL SETUP & LOGIN ---

        async function initMic() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                btnJoin.disabled = false;
                statusMsg.textContent = "Micr√≥fono listo. Ingresa tu ID.";
                statusMsg.style.color = "#00ff88";

                // Mic Visualizer for Login (Simple Analysis)
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(localStream);
                const analyser = audioCtx.createAnalyser();
                analyser.fftSize = 32;
                source.connect(analyser);

                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                function drawMic() {
                    analyser.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
                    let avg = sum / dataArray.length;
                    micBar.style.width = Math.min(100, avg * 2) + "%";
                    requestAnimationFrame(drawMic);
                }
                drawMic();

            } catch (err) {
                console.error(err);
                statusMsg.textContent = "Error: Acceso al micr√≥fono denegado.";
                statusMsg.style.color = "#ff004c";
            }
        }

        initMic(); // Request permission on load

        btnJoin.addEventListener('click', () => {
            const name = usernameInput.value.trim();
            if (!name) return alert("Por favor ingresa tu Minecraft ID");
            if (!localStream) return alert("No se detect√≥ el micr√≥fono");

            myUsername = name;
            startGame();
        });

        // --- 2. GAME LOBBY LOGIC ---

        function startGame() {
            // UI Switch
            loginView.classList.add('hidden');
            hudView.classList.remove('hidden');
            displayUsername.textContent = myUsername;

            // Audio Context Setup
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            masterGainNode = audioContext.createGain();
            masterGainNode.connect(audioContext.destination);

            // Setup Local Analyser for "Self Glow" & Scream Detection
            const localSource = audioContext.createMediaStreamSource(localStream);
            const localAnalyser = audioContext.createAnalyser();
            localAnalyser.fftSize = 64;
            localSource.connect(localAnalyser);
            startMicAnalysis(localAnalyser);

            // Connect to Socket & Peer
            connectSocket();
            connectPeer();
        }

        function connectSocket() {
            socket = io();

            socket.on('connect', () => {
                console.log("Socket connected:", socket.id);
            });

            socket.on('update-positions', (data) => {
                // data: [{ name, x, y, z, is_underground }, ...]
                playersState = data;
                updateProximityLogic();
                renderRadar();
            });
        }

        function connectPeer() {
            // Using username as PeerID for simplicity
            peer = new Peer(myUsername, {
                debug: 2
            });

            peer.on('open', (id) => {
                console.log('My Peer ID is: ' + id);
            });

            // Handle incoming calls
            peer.on('call', (call) => {
                console.log("Incoming call from:", call.peer);
                call.answer(localStream);
                handleCallStream(call);
            });

            // Handle incoming data (Screaming status)
            peer.on('connection', (conn) => {
                conn.on('data', (data) => {
                    if (data.type === 'SCREAMING') {
                        handleScreamEvent(conn.peer, data.value);
                    }
                });
                // Store connection
                if (!peers[conn.peer]) peers[conn.peer] = {};
                peers[conn.peer].conn = conn;
            });
        }

        // --- 3. CORE LOGIC ---

        function updateProximityLogic() {
            // Find my position
            const me = playersState.find(p => p.name === myUsername);
            if (!me) return; // Not in game yet

            playersState.forEach(player => {
                if (player.name === myUsername) return; // Skip self

                const dist = getDistance(me, player);
                const isNearby = dist <= MAX_DISTANCE;

                // 1. Connection Management
                if (isNearby) {
                    if (!peers[player.name]?.call) {
                        // Connect if not connected
                        callPeer(player.name);
                    }
                    // Update Audio Position
                    if (peers[player.name]?.panner) {
                        updateAudioPosition(player, me, peers[player.name]);
                    }
                } else {
                    // Close connection if far (optimization)
                    // In a real robust app, maybe just mute instead of disconnect to avoid thrashing
                    // For this requirements: "Cierra conexiones o silencia streams"
                    // We'll mute gain to 0 to keep connection alive but save processing? 
                    // Let's close call to be strict with requirement "Cierra conexiones... para optimizar CPU"
                    if (peers[player.name]?.call) {
                        peers[player.name].call.close();
                        delete peers[player.name].call;
                        delete peers[player.name].panner; // Cleanup audio nodes
                        delete peers[player.name].gain;
                    }
                }
            });

            // Clean up players who left server completely
            // (omitted for brevity, assume socket sends current snapshot)
        }

        function callPeer(remoteId) {
            console.log("Calling:", remoteId);
            const call = peer.call(remoteId, localStream);
            const conn = peer.connect(remoteId);

            if (!peers[remoteId]) peers[remoteId] = {};
            peers[remoteId].call = call;
            peers[remoteId].conn = conn; // Data channel for scream

            handleCallStream(call);
        }

        function handleCallStream(call) {
            call.on('stream', (remoteStream) => {
                // Setup Web Audio Graph for this peer
                // [Source] -> [Gain] -> [Panner] -> [Convolver] -> [Master]
                const source = audioContext.createMediaStreamSource(remoteStream);

                const gain = audioContext.createGain();
                const panner = audioContext.createPanner();
                const convolver = audioContext.createConvolver();

                // Configure Panner
                panner.panningModel = 'HRTF';
                panner.distanceModel = 'linear';

                // Create Impulse Response for Cave (Simple noise)
                const buffer = audioContext.createBuffer(2, audioContext.sampleRate * 2, audioContext.sampleRate);
                for (let i = 0; i < buffer.length; i++) {
                    // Simple noise decay
                    buffer.getChannelData(0)[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / buffer.length, 2);
                    buffer.getChannelData(1)[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / buffer.length, 2);
                }
                convolver.buffer = buffer;

                // Route: Default Bypass Convolver initially
                // We construct a graph where we can crossfade or switch convolver?
                // Simplest: Source -> Panner -> Gain -> Master
                // We'll insert Convolver dynamically or use a Dry/Wet mix.
                // Let's keep it simple: Source -> Panner -> Gain -> [Convolver?] -> Master

                source.connect(panner);
                panner.connect(gain);
                gain.connect(masterGainNode); // Initially connect directly (Dry)

                // Store nodes
                if (!peers[call.peer]) peers[call.peer] = {};
                peers[call.peer].panner = panner;
                peers[call.peer].gain = gain;
                peers[call.peer].convolver = convolver;
                peers[call.peer].isCave = false;
                peers[call.peer].source = source; // Keep ref
            });

            call.on('close', () => {
                console.log("Call closed:", call.peer);
            });
        }

        function updateAudioPosition(target, me, peerObj) {
            if (!peerObj.panner) return;

            // Relative Position
            // Web Audio Panner works in listeners coordinate system usually, or world.
            // Simplest: We set AudioListener to (0,0,0) and facing (0,0,-1).
            // Then we place Panner relative to that.

            // RelX = target.x - me.x
            // RelZ = target.z - me.z
            const relX = target.x - me.x;
            const relZ = target.z - me.z;
            const relY = target.y - me.y;

            peerObj.panner.positionX.value = relX;
            peerObj.panner.positionY.value = relY;
            peerObj.panner.positionZ.value = relZ;

            // Distance & Screaming Logic
            const dist = Math.sqrt(relX * relX + relZ * relZ);

            if (peerObj.isScreaming) {
                // Screaming: Hear up to 60m
                // Map 0-60m to Gain 1-0
                let volume = 1 - (dist / MAX_DISTANCE);
                if (volume < 0) volume = 0;
                peerObj.gain.gain.value = volume;
            } else {
                // Normal: Hear up to 20m
                let volume = 1 - (dist / NORMAL_ROLLOFF);
                if (volume < 0) volume = 0;
                peerObj.gain.gain.value = volume;
            }

            // Cave Logic
            // If target is underground => Activate Convolver
            if (target.is_underground) {
                if (!peerObj.isCave) {
                    // Switch to wet path
                    peerObj.gain.disconnect();
                    peerObj.gain.connect(peerObj.convolver);
                    peerObj.convolver.connect(masterGainNode);
                    peerObj.isCave = true;
                }
            } else {
                if (peerObj.isCave) {
                    // Switch back to dry
                    peerObj.convolver.disconnect();
                    peerObj.gain.disconnect();
                    peerObj.gain.connect(masterGainNode);
                    peerObj.isCave = false;
                }
            }
        }

        function startMicAnalysis(analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount);

            setInterval(() => {
                analyser.getByteFrequencyData(data);
                // Calculate average volume
                let sum = 0;
                for (let i = 0; i < data.length; i++) sum += data[i];
                const avg = sum / data.length;

                // Visual Glow
                const isTalking = avg > 10;
                if (isTalking) {
                    selfGlow.classList.add('active');
                } else {
                    selfGlow.classList.remove('active');
                }

                // Check Scream (> -5dB approx). 
                // ByteData is 0-255. 0 is silence (-Infinity dB), 255 is 0dB approx.
                // -5dB is roughly top 90% of scale? ~230?
                // Let's tone is down for easy testing: say > 200 (approx -10dB to -5dB range)
                const isScreaming = avg > 200;

                // Send to all peers
                Object.values(peers).forEach(p => {
                    if (p.conn && p.conn.open) {
                        // Only send if state changed to avoid flood (simple debounce needed in real app)
                        p.conn.send({ type: 'SCREAMING', value: isScreaming });
                    }
                });

            }, 100);
        }

        function handleScreamEvent(peerId, isScreaming) {
            if (peers[peerId]) {
                peers[peerId].isScreaming = isScreaming;
                // UI feedback in radar
                const card = document.getElementById(`card-${peerId}`);
                if (card) {
                    const statusText = card.querySelector('.status-text');
                    if (isScreaming) {
                        statusText.innerHTML = '<span class="status-badge bg-scream">üò± GRITANDO</span>';
                    } else {
                        // Revert will happen on next renderRadar frame based on state
                    }
                }
            }
        }

        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.z - p2.z, 2));
        }

        // --- 4. RENDER UI ---

        function renderRadar() {
            radarList.innerHTML = '';

            const me = playersState.find(p => p.name === myUsername);
            if (!me) return;

            // Sort by distance
            const others = playersState
                .filter(p => p.name !== myUsername)
                .map(p => ({ ...p, dist: getDistance(me, p) }))
                .sort((a, b) => a.dist - b.dist);

            others.forEach(player => {
                const isNear = player.dist <= MAX_DISTANCE;
                const isScreaming = peers[player.name]?.isScreaming || false;

                // Status Badge Helper
                let statusHtml = '';
                if (isScreaming) statusHtml += '<span class="status-badge bg-scream">üò± GRITANDO</span>';
                if (player.is_underground) statusHtml += '<span class="status-badge bg-cave">üè† CUEVA</span>';
                if (!statusHtml) statusHtml = '<span class="status-badge" style="background:#333;color:#aaa">NORMAL</span>';

                const div = document.createElement('div');
                div.id = `card-${player.name}`;
                div.className = `player-card ${isNear ? 'in-range' : 'out-range'}`;
                div.innerHTML = `
                    <div class="player-info">
                        <div class="player-name">${player.name}</div>
                        <div class="player-details status-text">
                            ${statusHtml}
                        </div>
                    </div>
                    <div class="distance-indicator" style="color: ${isNear ? '#00ff88' : '#555'}">
                        ${Math.round(player.dist)}m
                    </div>
                `;
                radarList.appendChild(div);
            });
        }

        // --- Controls ---
        btnToggleMute.addEventListener('click', () => {
            if (localStream) {
                isMuted = !isMuted;
                localStream.getAudioTracks()[0].enabled = !isMuted;
                btnToggleMute.textContent = isMuted ? "MIC OFF" : "MIC ON";
                btnToggleMute.classList.toggle('muted', isMuted);
            }
        });

        masterVolumeSlider.addEventListener('input', (e) => {
            if (masterGainNode) {
                masterGainNode.gain.value = e.target.value;
            }
        });

    </script>
</body>

</html>